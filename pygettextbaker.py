#!/usr/bin/env python3
# -*- coding: utf-8 -*-

APPNAME = "pygettext-baker"
VERSION = "0.1"

import os
import sys
import subprocess
import argparse
import hashlib
import gettext
import inspect

def load_trans(fn, pofn):
    # check file stamp
    comppo = False
    if not os.path.exists(fn):
        if os.path.exists(pofn):
            comppo = True
    elif os.path.exists(pofn):
        if os.path.getmtime(fn) < os.path.getmtime(pofn):
            comppo = True
    if comppo:
        print("Compile", pofn, "->", fn)
        subprocess.check_call(["msgfmt", pofn, "-o", fn])
    print("Loading", fn)
    with open(fn, "rb") as f:
        gettext.GNUTranslations(f) # check if loadable
        f.seek(0)
        return f.read()

def loaddomains(source):
    # read .mo
    locpath = os.path.dirname(source)
    # scan all languages
    langs = {}
    domains = []
    for lang in os.listdir(locpath):
        langpath = os.path.join(locpath, lang)
        if not os.path.isdir(langpath):
            continue
        langfolder = os.path.join(langpath, "LC_MESSAGES")
        if not os.path.exists(langfolder): continue
        # scan all .mo/.po
        langs[lang] = {}
        for domain in os.listdir(langfolder):
            domainfile = os.path.join(langfolder, domain)
            if not os.path.isfile(domainfile): continue
            domname = domain
            if domname[-3:] in (".po", ".mo"):
                domname = domname[:-3]
            if domname not in langs[lang]:
                langs[lang][domname] = load_trans(
                    os.path.join(langfolder, domname + ".mo"),
                    os.path.join(langfolder, domname + ".po"))
            if domname not in domains:
                domains.append(domname)  
    return (langs, domains)

def domain_pyfile(f, mofile, domain, no_hdr = False):
    def write(msg):
        f.write(msg + "\n")
    if not no_hdr:
        write("# -*- coding: utf-8 -*-")
        write("# Autogenerated by " + APPNAME + ", " + VERSION)
        write("")
    write("# Domain: {}".format(domain))
    data = mofile
    st = "_mo_{} = b'".format(domain)
    nx = ""
    while len(data) > 0:
        if len(st + nx) > 77:
            write(st + "'\\")
            st = "    b'" + nx
        else:
            st += nx
        if data[0] >= 32 and data[0] < 128:
            nx = "{:c}".format(data[0])
        else:
            nx = "\\x{:02x}".format(data[0])
        data = data[1:]
    write(st + nx + "'")
    write("")

def create_init_pyfile(f, langs):
    def write(msg):
        f.write(msg + "\n")
    write("# -*- coding: utf-8 -*-")
    write("# Autogenerated by " + APPNAME + ", " + VERSION)
    # copy licence notes from top of file
    write("# following code are based on getext.py module")
    write("")
    for line in inspect.getsource(gettext).split("\n"):
        if line.startswith("import"): break
        write(line)
    
    write("")
    write("_mo_langs = {")
    for lang in langs:
        write("    {}: {},".format(repr(lang), repr(list(langs[lang].keys()))))
    write("}")
    write("")
    # clone functions
    write("import os")
    write("import io")
    write("import copy")
    write("import gettext as _gettext")
    write("")
    exc_list = ["c2py", "_expand_lang"]
    for item, itemtp in inspect.getmembers(gettext):
        if item[:2] == item[-2:] == "__": continue
        iobj = getattr(gettext, item)
        if item in ("find", "translation", "Catalog"):
            pass
        elif inspect.isfunction(iobj) \
                and itemtp.__name__ == item and item not in exc_list:
            print("Copy function", item)
            write("".join(inspect.getsourcelines(iobj)[0]))
        else:
            if not inspect.ismodule(iobj):
                write("{n} = _gettext.{n}".format(n = item))
    write("""def find(domain, localedir=None, languages=None, all=False):
    # Get some reasonable defaults for arguments that were not supplied
    if localedir is None:
        localedir = _default_localedir
    if languages is None:
        languages = []
        for envar in ('LANGUAGE', 'LC_ALL', 'LC_MESSAGES', 'LANG'):
            val = os.environ.get(envar)
            if val:
                languages = val.split(':')
                break
        if 'C' not in languages:
            languages.append('C')
    # now normalize and expand the languages
    nelangs = []
    for lang in languages:
        for nelang in _expand_lang(lang):
            if nelang not in nelangs:
                nelangs.append(nelang)
    # select a language
    if all:
        result = []
    else:
        result = None
    for lang in nelangs:
        if lang == 'C':
            break
        if lang not in _mo_langs: continue
        if domain not in _mo_langs[lang]: continue
        mofile = (lang, domain)
        if all:
            result.append(mofile)
        else:
            return mofile
    return result
    
def translation(domain, localedir=None, languages=None,
                class_=None, fallback=False, codeset=None):
    if class_ is None:
        class_ = GNUTranslations
    mofiles = find(domain, localedir, languages, all=True)
    if not mofiles:
        if fallback:
            return NullTranslations()
        raise OSError(ENOENT, 'No translation file found for domain', domain)
    # Avoid opening, reading, and parsing the .mo file after it's been done
    # once.
    result = None
    for mofile in mofiles:
        key = (class_, mofile)
        t = _translations.get(key)
        if t is None:
            data = None
            lang, domain = mofile
            if lang in _mo_langs and domain in _mo_langs[lang]:""")
    for idx, lang in enumerate(langs):
        write("                " + ("if" if idx == 0 else "elif") +
            "  lang == {}:".format(repr(lang)))
        write("                    from .{} import _mo".format(lang))
        write("                    data = _mo.get(domain, None)")
    write("""            if data:
                fp = io.BytesIO(data)     
                t = _translations.setdefault(key, class_(fp))
        # Copy the translation object to allow setting fallbacks and
        # output charset. All other instance data is shared with the
        # cached object.
        t = copy.copy(t)
        if codeset:
            t.set_output_charset(codeset)
        if result is None:
            result = t
        else:
            result.add_fallback(t)
    return result
Catalog = translation""")
    
def finish_domains_pyfile(f, domains):
    def write(msg):
        f.write(msg + "\n")
    write("_mo = {")
    for domain in domains:
        write("    {}: _mo_{},".format(repr(domain), domain))
    write("}")

def safelang(lang):
    return lang.replace("@", "_at_").replace(".", "_dot_")

def baker(source, destination):
    langs, alldomains = loaddomains(source)
    for lang, domains in langs.items():
        with open(os.path.join(destination, "{}.py".format(safelang(lang))), 
            "w", encoding = "UTF-8-sig") as f:
            cnt = 0
            for idx, (domain, mofile) in enumerate(domains.items()):
                domain_pyfile(f, mofile, domain, no_hdr = (idx != 0))
            finish_domains_pyfile(f, domains)
    with open(os.path.join(destination, "__init__.py"), "w",
        encoding = "UTF-8-sig") as f:
        create_init_pyfile(f, langs)

def main():
    print(APPNAME + ", " + VERSION)
    print("\tRoman Kharin (romiq.kh@gmail.com)")
    if len(sys.argv) < 2:
        print("Use -h for help.")
        return

    parser = argparse.ArgumentParser()
    parser.add_argument('source', help = "path to source")
    parser.add_argument("destination", 
        help = "path to destination folder")
    
    args = parser.parse_args()
    return baker(**vars(args))
    
if __name__ == "__main__":
    sys.exit(main())

